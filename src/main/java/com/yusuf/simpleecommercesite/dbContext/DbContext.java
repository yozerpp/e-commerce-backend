package com.yusuf.simpleecommercesite.dbContext;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.yusuf.simpleecommercesite.dbContext.sqlUtils.SqlTypeConverter;
import com.yusuf.simpleecommercesite.entities.annotations.*;
import com.yusuf.simpleecommercesite.helpers.ErrandBoy;
import com.yusuf.simpleecommercesite.dbContext.sqlUtils.StatementBuilder;
import net.sf.cglib.proxy.*;

import javax.sql.DataSource;
import java.io.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

public class DbContext {
    private static final Class<? extends Annotation>[] notMappedFieldAnnotations= new Class[]{OneToMany.class};
    final ObjectMapper mapper;
    final SqlTypeConverter typeConverter;
    private final static int CACHE_MAX_SIZE=500;
    private final Set<Object> idCache =Collections.synchronizedSet(new HashSet<>(2000));
//    private final Map<Map<String,Object>, List<Object>> searchCache=new ConcurrentHashMap<>();
    private final Map<Object, Set<String>> dirtMap=new ConcurrentHashMap<>();
    private final Map<Class<?>, Map<String,String>>  fieldNameMappings=new HashMap<>();
    private DataSource dataSource;
    private Connection connectionn;
    private boolean connectionMode=false;
    public DbContext(ObjectMapper mapper, DataSource dataSource){
        this.mapper = mapper;
        this.dataSource=dataSource;
        this.typeConverter=new SqlTypeConverter(this.mapper);
    }
    public DbContext(ObjectMapper mapper, Connection connection){
        this.mapper=mapper;
        this.connectionn=connection;
        this.connectionMode=true;
        this.typeConverter=new SqlTypeConverter(this.mapper);
    }
    public <T> T findById(Class<T> clazz, Object... ids) {
        T entity = instantiate(clazz, ids);
        try {
            return findAndFill(entity);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
    public <T> List<T> search(Class<T> clazz ,Map<String,Object> params) {
        params= replaceWithColumnName(params, fieldNameMappings.containsKey(clazz)?fieldNameMappings.get(clazz):createColumnNameMapping(clazz));
//        if (clazz.equals(Product.class) && this.searchCache.containsKey(params)) return (List<T>) this.searchCache.get(params);
        Connection connection= null;
        PreparedStatement statement = null;
        try {
            connection = getConnection();
            statement=buildSearchStatement(ErrandBoy.getRealClass(clazz).getSimpleName().toLowerCase(Locale.ENGLISH), params, connection);
            ResultSet results=statement.executeQuery();
            List<T> entities= createWithResults(clazz, results);
            entities.replaceAll(this::toProxy);
//            this.searchCache.put(params, (List<Object>) entities);
//            if(this.searchCache.size()>CACHE_MAX_SIZE) {
//                synchronized (searchCache) {
//                    Map.Entry<Map<String, Object>, List<Object>> e = this.searchCache.entrySet().stream().findFirst().get();
//                    e.getValue().clear();
//                    this.searchCache.remove(e.getKey());
//                }
//            }
            return entities;
        } catch (NoSuchMethodException | SQLException | InvocationTargetException | IllegalAccessException |
                 InstantiationException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                if(statement!=null)
                    statement.close();
                close(connection);
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
    }
    public <T> T save(T entity, boolean... flags) throws SQLException {
            if (isProxy(entity))
                update(entity,false);
            else
                try{
                    entity=insert(entity);
                } catch (SQLException e){
                    if (Objects.equals(e.getErrorCode(), 1062)/*|e.getErrorCode()==1048*/) update(entity, false);
                    else throw e;
                }
        return  entity;
    }

    public <T> T merge(T e){
        if (!isProxy(e))
            e=toProxy(e);
        removeFromCache(e);
        try {
            e= findAndFill(e);
        } catch (SQLException ex) {
            throw new RuntimeException(ex);
        }
        return e;
    }
    public   <T> T insert(T entity) throws SQLException {
        Connection connection=null;
        PreparedStatement statement = null;
        try {
            Field aiField=ErrandBoy.getAnnotatedField(entity.getClass(), AutoGenerated.class);
            connection= getConnection();
            statement=buildStatement(entity, StatementBuilder.StatementType.INSERT, connection, false);
            statement.executeUpdate();
            if(aiField!=null)
                retrieveGeneratedKey(entity, statement.getGeneratedKeys(), aiField.getName());
            entity=toProxy(entity);
            removeFromCache(entity);
            return entity;
        } catch (InvocationTargetException | IllegalAccessException | IOException | NoSuchMethodException |
                 InstantiationException e) {
            e.printStackTrace(System.err);
            throw new RuntimeException(e);
        }finally {
            if(statement!=null)
                statement.close();
            close(connection);
        }
    }
    private void removeFromCache(Object entity) {
        Class<?> cls=ErrandBoy.getRealClass(entity);
            if(cls.isAnnotationPresent(AggregateMember.class)){
                AggregateMember aggregateOwner=cls.getAnnotation(AggregateMember.class);
                for(Method method: ErrandBoy.getRealClass(entity).getDeclaredMethods() ){
                    if(method.getReturnType().isAssignableFrom(aggregateOwner.in())){
                        try {
                            idCache.remove(method.invoke(entity));
                        } catch (IllegalAccessException | InvocationTargetException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        idCache.remove(entity);
    }
    public int update(Object entity, boolean updateNull) throws SQLException {
        if (!isProxy(entity))
            entity=toProxy(entity);
        removeFromCache(entity);
        PreparedStatement statement = null;
        Connection connection=null;
        try{
            connection= getConnection();
            statement= buildStatement(entity, StatementBuilder.StatementType.UPDATE, connection, updateNull);
            int res= statement.executeUpdate();
            return res;
        } catch (InvocationTargetException | IllegalAccessException e) {
            throw new RuntimeException(e);
        } finally {
            if(statement!=null)
                statement.close();
            close(connection);
        }
    }
    <T> T findAndFill(T entity) throws SQLException {
        if (!isProxy(entity))
            entity= toProxy(entity);
        Connection connection= null;
        PreparedStatement statement=null;
        if (this.idCache.contains(entity)) return getFromCache(entity);
        try {
            connection= getConnection();
            statement= buildStatement(entity, StatementBuilder.StatementType.SELECT, connection, false);
            ResultSet rs=statement.executeQuery();
            if(!populateWithResult(entity, rs, false))
                return null;
        } catch (SQLException | InvocationTargetException | IllegalAccessException e) {
            throw new RuntimeException(e);
        } finally {
            if(statement!=null)
                statement.close();
            close(connection);
        }
        this.idCache.add(entity);
        if(this.idCache.size()>CACHE_MAX_SIZE) {
            synchronized (idCache) {
                removeFromCache(idCache.stream().findFirst().get());
            }
        }
        return entity;
    }
    private <T> T toProxy(T entity){
        Enhancer proxy= new Enhancer();
        proxy.setSuperclass(entity.getClass());
        proxy.setCallback(new EntityMethodInterceptor(this, entity));
        dirtMap.put(entity, new CopyOnWriteArraySet<>());
        entity= (T) proxy.create();
        return entity;
    }
    private boolean isProxy(Object e){
        return e.getClass().getSimpleName().contains("$$Enhancer");
    }
    private Map<String,String> createColumnNameMapping(Class<?> clazz){
        Map<String,String> mapping=new HashMap<>();
        for (Field field: clazz.getDeclaredFields()){
            String columnName=getColumnName(field);
            if(!field.getName().equals(columnName)) {
                mapping.put(field.getName(), columnName);
            }
        }
        fieldNameMappings.put(clazz, mapping);
        return mapping;
    }
    private static Map<String, Object> replaceWithColumnName(Map<String, Object> params, Map<String, String> mapping){
        Map<String, Object> ret=new HashMap<>();
        for (Map.Entry<String, Object> param: params.entrySet()){
            String columnName=mapping.get(param.getKey());
            ret.put(columnName!=null?columnName:param.getKey(), param.getValue());
        }
        return ret;
    }
    private void close(Connection connection) throws SQLException {
        if (!connectionMode)
            if(connection!=null)
                connection.close();
    }
    public <T> T fetchLOb(T entity, String fieldName){
        Connection connection=null;
        PreparedStatement statement=null;
         try {
            connection=getConnection();
            statement=buildStatement(entity, StatementBuilder.StatementType.SELECT, connection, false);
            populateWithResult(entity, statement.executeQuery(), true, fieldName);

            return entity;
        } catch (SQLException | InvocationTargetException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }finally {
             try {
                 if(statement!=null)
                     statement.close();
                 close(connection);
             } catch (SQLException e){throw new RuntimeException(e);}
         }
    }
    public <T> T saveWithNulls(T entity) throws SQLException {
        if(update(entity, true)==0)
            insert(entity);
        idCache.remove(entity);
        idCache.add(entity);
        return  entity;
    }

    public int remove(Object entity){
        try {
            Connection connection=getConnection();
            PreparedStatement statement= buildStatement(entity, StatementBuilder.StatementType.DELETE, connection, false);
            int res=statement.executeUpdate();
            statement.close();
            close(connection);
            if(!isProxy(entity)) entity=toProxy(entity);
            removeFromCache(entity);
            return res;
        } catch (SQLException | InvocationTargetException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
    private Connection getConnection() throws SQLException {
        if (this.dataSource!=null) {
            return dataSource.getConnection();
        }
        else if (this.connectionn!=null) return this.connectionn;
        else throw new RuntimeException("NO CONNECTION SOURCE");
    }
    public void addDirtyField(Object entity, String fieldName){
        dirtMap.get(entity).add(fieldName);
    }
    private synchronized <T> T getFromCache(T entity){
        for (Object cached : idCache) {
            if (entity.equals(cached)) return (T) cached;
        }
        return null;
    }
    private <T> List<T> createWithResults(Class<T> clazz, ResultSet resultSet) throws NoSuchMethodException, SQLException, InvocationTargetException, IllegalAccessException, InstantiationException {
        List<T> entities=new ArrayList<>();
        T entity=clazz.getConstructor().newInstance();
        while (populateWithResult(entity, resultSet, false)){
            entities.add(entity);
            entity=clazz.getConstructor().newInstance();
        }
        return entities;
    }
    private boolean retrieveGeneratedKey(Object entity, ResultSet resultSet, String fieldName) throws SQLException, InvocationTargetException, IllegalAccessException, IOException, NoSuchMethodException, InstantiationException {
        if(!resultSet.next()) return false;
        Class<?> clazz=entity.getClass();
        if (clazz.getSimpleName().contains("$$Enhancer")) clazz=clazz.getSuperclass();
        for (Field field:clazz.getDeclaredFields())
            if (field.getName().equals(fieldName)) {
                invokeSetter(entity, resultSet.getObject(1), field);
            }
        return true;
    }
    private void invokeSetter(Object entity, Object value, Field field) throws IllegalArgumentException, IOException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        Method setter= findSetter(field, ErrandBoy.getRealClass(entity));
        setter.invoke(entity, typeConverter.convertToJavaType(value, setter.getParameterTypes()[0]));
    }
    private boolean populateWithResult(Object entity, ResultSet resultSet, boolean fetchLOb, String... fieldNames) throws SQLException, InvocationTargetException, IllegalAccessException {
        try {
            boolean populateAllFields=(fieldNames != null ? fieldNames.length : 0) ==0;
            int i=1;
            if (!resultSet.next()) return false;
            for (Field field:ErrandBoy.getRealClass(entity).getDeclaredFields()){
                if (isNotMapped(field) || (isLOb(field) && !fetchLOb) || (!populateAllFields && Arrays.stream(fieldNames).noneMatch(fieldName-> field.getName().equals(fieldName)))) continue;
                invokeSetter(entity,resultSet.getObject(getColumnName(field)),field);
            }
            return true;
        } catch (IOException | NoSuchMethodException | InstantiationException | IllegalArgumentException e) {
            throw new RuntimeException(e);
        }
    }
    private PreparedStatement buildSearchStatement(String table ,Map<String,Object> params, Connection connection) throws SQLException {
        StatementBuilder builder=new StatementBuilder(StatementBuilder.StatementType.SELECT);
        builder.table(table);
        int page=0;
        int size=20;
        for (Map.Entry <String,Object> entry:params.entrySet()) {
            if(entry.getKey().equals("page")) page= Integer.parseInt(entry.getValue().toString());
            else if(entry.getKey().equals("size")) size= Integer.parseInt(entry.getValue().toString());
            else {
                String key;
                 if (entry.getKey().endsWith("High"))
                    builder.where(key=entry.getKey().replace("High", ""), entry.getValue(), "<");
                else if (entry.getKey().endsWith("Low"))
                    builder.where(key=entry.getKey().replace("Low", ""), entry.getValue(), ">");
                else if (entry.getKey().endsWith("Desc"))
                    builder.order(key=entry.getKey().replace("Desc", ""), true);
                else if (entry.getKey().endsWith("Asc"))
                    builder.order(key=entry.getKey().replace("Asc", ""), false);
                else builder.where(key=entry.getKey(), entry.getValue());
            }
        }
        builder.page(page,size);
        return builder.build(connection);
    }
    public void clear(){
        synchronized (idCache) {
            this.idCache.clear();
        }
        synchronized (dirtMap) {
            this.dirtMap.forEach((key, value) -> value.clear());
            this.dirtMap.clear();
        }
//        synchronized (searchCache) {
//            this.searchCache.forEach((key, value) -> value.clear());
//            this.searchCache.clear();
//        }
    }
    private static boolean isDefault(Object val){
        return (val == null || val.toString().trim().isEmpty() || ((val instanceof Boolean)) && ((Boolean) val).booleanValue()) || (val instanceof Number && ((Number)val).equals(0));
    }
    private PreparedStatement buildStatement(Object entity, StatementBuilder.StatementType type, Connection connection, boolean defaults) throws InvocationTargetException, IllegalAccessException, SQLException {
        Class<?> clazz=ErrandBoy.getRealClass(entity);
        StatementBuilder builder=new StatementBuilder(type, defaults);
        builder.table(clazz.getSimpleName().toLowerCase(Locale.ENGLISH));
        for(Field field: clazz.getDeclaredFields()){
            if (isNotMapped(field)) continue;
            String columnName=getColumnName(field);
            Object value=typeConverter.convertToSqlType(findGetter(field, clazz).invoke(entity), connection);
            if(field.isAnnotationPresent(Id.class) && builder.getType()!= StatementBuilder.StatementType.INSERT)
                builder.where(columnName, value);
            builder.param(columnName, value);
        }
        return builder.build(connection);
    }
    private static boolean isLOb(Field field){
        return byte[].class.isAssignableFrom(field.getType()) | char[].class.isAssignableFrom(field.getType());
    }
    private <T> T instantiate(Class<T> clazz, Object... ids){
        try {
            return clazz.getConstructor( Arrays.stream(ids).map(id->ensurePrimitive(id.getClass())).toArray(Class[]::new)).newInstance(ids);
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }
    private static Class<?> ensurePrimitive(Class<?> val) {
        Class<?> ret = val;
        if (ret.equals(Integer.class)) ret = int.class;
        else if (ret.equals(Boolean.class)) ret = boolean.class;
        return ret;
    }
    private static boolean isNotMapped(Field field){
        for (Class<? extends Annotation> notMappedFieldAnnotation : notMappedFieldAnnotations) {
            if (field.isAnnotationPresent(notMappedFieldAnnotation)) return true;
        }
        return false;
    }
    private static Method findGetter(Field field, Class<?> clazz){
        String pre;
       if (boolean.class.isAssignableFrom(field.getType())){
           pre="is";
       } else pre="get";
        try {
            return clazz.getDeclaredMethod(pre + ErrandBoy.firstLetterToUpperCase(field.getName()));
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }
    private static Method findSetter(Field field, Class<?> clazz){
        return Arrays.stream(clazz.getDeclaredMethods())
                .filter(method -> method.getName().matches("^(set)" + ErrandBoy.firstLetterToUpperCase(field.getName())))
                .findFirst().orElse(null);
    }
    private static String getColumnName(Field field) {
        Annotation annotation;
        if((annotation=field.getDeclaredAnnotation(OneToOne.class))!=null) return  ((OneToOne) annotation).joinColumn();
//        else if ((annotation=field.getDeclaredAnnotation(OneToMany.class))!=null) return ((OneToMany) annotation).inverseJoinColumn();
        else if ((annotation=field.getAnnotation(ManyToOne.class))!=null) return ((ManyToOne) annotation).joinColumn();
        else if((annotation=field.getAnnotation(Column.class))!=null && !Objects.equals(((Column) annotation).name(), "")) return ((Column) annotation).name();
        else return field.getName();
    }
}
